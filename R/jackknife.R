# Vaguely adapted from bootstrap package, with three modifications:
# 1) Estimate the model only once for each cell of the table,
# and compute a mean weighted by cell frequencies at the end
# (Wong, Association models, 2010, p. 28-29; Clogg & Shihadeh, 1994, p. 34-38)
# 2) theta must return a vector rather than a single number,
# to allow handling a series of parameters in the same run
# 3) The variance-covariance matrix is returned, instead of standard errors
#
# Formula taken from original function and from e.g. Steinhauer & Wuergler, 2010,
# "Leverage and Covariance Matrix Estimation in Finite-Sample IV Regressions", p. 11.
# (adapted to work with table cell weights).
#
# Objects needed by theta() on the cluster nodes can be passed as arguments and handled
# in theta(), or simply passed as *named* arguments to jackknife(): they will be exported
# the the nodes' environments. 
jackknife <- function(x, theta, ..., w=rep(1, length(x)),
                      ncpus=if(require(parallel)) getOption("cl.cores", detectCores()) else getOption("cl.cores", 2))
{
    call <- match.call()
    stopifnot(length(w) == length(x))
    w <- as.numeric(w)
    stopifnot(all(w >= 0))
    n <- length(x)
    u <- vector("list", n)

    # Run this first to find out caller errors before running parLapply
    thetahat <- as.numeric(theta(x, ...))

    if(ncpus > 1 && require(parallel)) {
        cl <- makeCluster(ncpus)
        on.exit(stopCluster(cl))

        dots <- list(...)
        dotsnames <- names(dots)

        if(length(dotsnames[dotsnames != ""]) > 0)
            clusterExport(cl, dotsnames[dotsnames != ""], as.environment(dots[dotsnames != ""]))

        u <- parLapply(cl, 1:n, function(i, x, theta, ...) theta(x[-i], ...), x, theta, ...)
    }
    else if(ncpus > 1 && require(snow)) {
        cl <- snow::makeCluster(rep("localhost", ncpus), type="SOCK")
        on.exit(snow::stopCluster(cl))

        dots <- list(...)
        dotsnames <- names(dots)

        if(length(dotsnames[dotsnames != ""]) > 0) {
            # clusterExport() in snow 0.3-3 does not take an 'envir' argument
#             envir <- as.environment(dots[dotsnames != ""])
#             environment(clusterExport) <- envir
            clusterExport(cl, dotsnames[dotsnames != ""])
        }

        u <- snow::clusterApply(cl, 1:n, function(i, x, theta, ...) theta(x[-i], ...), x, theta, ...)
    }
    else {
        for(i in 1:n) {
            u[[i]] <- as.numeric(theta(x[-i], ...))
        }
    }
    u <- do.call(cbind, u)
    tot <- sum(w)
    mean.u <- rowSums(sweep(u, 2, w, "*"))/tot
    jack.bias <- (tot - 1) * (mean.u - thetahat)
    dev.u <- sweep(u, 1, mean.u, "-")
    jack.vcov <- (tot - 1)/tot * sweep(dev.u, 2, w, "*") %*% t(dev.u)
    return(list(jack.vcov = jack.vcov, jack.bias = jack.bias, jack.values = u, 
                call = call))
}

# Additional arguments are needed so that update() finds them even when using parLapply
theta.assoc <- function(x, model, assoc1, assoc2, family, weighting, ..., base=NULL, verbose=FALSE) {
  data <- model$data
  library(gnm)

  if(verbose) {
      iter <- which(!1:length(data) %in% x)
      if(length(iter) == 1)
          cat("Iteration for cell", iter, "\n")
      else
          cat("Ending iteration\n")
  }

  if(sum(data[-x]) > 0) {
      tab <- data
      tab[] <- -1
      tab[x] <- 0

      model <- update(model, data=data+tab, start=parameters(model), verbose=FALSE, trace=TRUE)

      if(!model$converged && !is.null(base)) {
          cat("Model for cell ", which(!1:length(data) %in% x),
              " did not converge, starting again with random values...\n")
          # If we don't specify start, old values are used, which can give very bad initial fits
          base <- update(base, data=data, start=rep(NA, length(parameters(base))))
          model <- update(model, iterMax=5 * model$iterMax,
                          start=c(parameters(base), rep(NA, length(parameters(model)) - length(parameters(base)))),
                          verbose=TRUE, trace=TRUE)
      }

      if(!model$converged)
          stop("Model for cell ", which(!1:length(data) %in% x), " did not converge!")
  }

  ass1 <- assoc1(model, weighting=weighting)
  ret <- c(t(ass1$phi))

  if(dim(ass1$row)[3] == 1) {
      # Even if the scores are the same for all layers, we replicate them for simplicity's sake
      for(i in 1:nrow(ass1$phi))
           ret <- c(ret, ass1$row[,,1], ass1$col[,,1],
                    sweep(ass1$row[,,1], 2, sqrt(abs(ass1$phi[i,])) * sign(ass1$phi[i,]), "*"),
                    sweep(ass1$col[,,1], 2, sqrt(abs(ass1$phi[i,])) * sign(ass1$phi[i,]), "*"))
  }
  else {
      for(i in 1:dim(ass1$row)[3])
           ret <- c(ret, ass1$row[,,i], ass1$col[,,i],
                    sweep(ass1$row[,,i], 2, sqrt(abs(ass1$phi[i,])) * sign(ass1$phi[i,]), "*"),
                    sweep(ass1$col[,,i], 2, sqrt(abs(ass1$phi[i,])) * sign(ass1$phi[i,]), "*"))
  }

  # For double association models like some hmskew and yrcskew variants
  if(!is.null(assoc2)) {
      ass2 <- assoc2(model, weighting=weighting)
      ret <- c(ret, t(ass2$phi))

      if(dim(ass2$row)[3] == 1) {
          # Even if the scores are the same for all layers, we replicate them for simplicity's sake
          for(i in 1:nrow(ass2$phi))
               ret <- c(ret, ass2$row[,,1], ass2$col[,,1],
                        sweep(ass2$row[,,1], 2, sqrt(abs(ass2$phi[i,])) * sign(ass2$phi[i,]), "*"),
                        sweep(ass2$col[,,1], 2, sqrt(abs(ass2$phi[i,])) * sign(ass2$phi[i,]), "*"))
      }
      else {
          for(i in 1:dim(ass2$row)[3])
               ret <- c(ret, ass2$row[,,i], ass2$col[,,i],
                        sweep(ass2$row[,,i], 2, sqrt(abs(ass2$phi[i,])) * sign(ass2$phi[i,]), "*"),
                        sweep(ass2$col[,,i], 2, sqrt(abs(ass2$phi[i,])) * sign(ass2$phi[i,]), "*"))
      }

  }

  ret
}

# theta.yrcskew <- function(x, model, assoc1, assoc2, family, weighting, ..., base=NULL, verbose=FALSE) {
#   library(gnm)
# 
#   data <- model$data
# 
#   if(verbose) {
#       iter <- which(!1:nrow(data) %in% x)
#       if(length(iter) == 1)
#           cat("Iteration for cell", iter, "\n")
#       else
#           cat("Ending iteration\n")
#   }
# 
#   if(sum(data[-x,"Freq"]) > 0) {
#       data[-x,"Freq"] <- data[-x,"Freq"] - 1
# 
#       model <- update(model, data=data, start=parameters(model), verbose=FALSE, trace=TRUE)
# 
#       if(!model$converged && !is.null(base)) {
#           cat("Model for cell ", which(!1:nrow(data) %in% x),
#               " did not converge, starting again with random values...\n")
#           # If we don't specify start, old values are used, which can give very bad initial fits
#           base <- update(base, data=data, start=rep(NA, length(parameters(base))))
#           model <- update(model, iterMax=5 * model$iterMax,
#                           start=c(parameters(base), rep(NA, length(parameters(model)) - length(parameters(base)))),
#                           verbose=TRUE, trace=TRUE)
#       }
# 
#       if(!model$converged)
#           stop("Model for cell ", which(!1:nrow(data) %in% x), " did not converge!")
#   }
# 
#   ass1 <- assoc1(model, weighting=weighting)
#   ret <- c(ass1$phi, ass1$row, ass1$col,
#            sweep(ass1$row, 2, sqrt(ass1$phi), "*"),
#            sweep(ass1$col, 2, sqrt(ass1$phi), "*"))
# 
#   # For double association models like some hmskew and yrcskew variants
#   if(!is.null(assoc2)) {
#       ass2 <- assoc2(model, weighting=weighting)
#       ret <- c(ret, ass2$phi, ass2$row, ass2$col,
#                     sweep(ass2$row, 2, sqrt(ass2$phi), "*"),
#                     sweep(ass2$col, 2, sqrt(ass2$phi), "*"))
#   }
# 
#   ret
# }

se <- function(x, ...) UseMethod("se", x)

se.default <- function(x, ...) gnm::se(x)

se.rc <- function(x, type=c("se", "quasi.se"), ...) {
  if(!inherits(x, "rc")) 
      stop("x must be a rc object")

  if(length(x$assoc) == 0)
      stop("x must have an association component")

  se.assoc(x$assoc)
}

se.rcL <- function(x, type=c("se", "quasi.se"), ...) {
  if(!inherits(x, "rcL")) 
      stop("x must be a rcL object")

  if(length(x$assoc) == 0)
      stop("x must have an association component")

  se.assoc(x$assoc)
}

se.hmskew <- function(x, type=c("se", "quasi.se"), ...) {
  if(!inherits(x, "hmskew"))
      stop("x must be a hmskew object")

  if(length(x$assoc) > 0 && length(x$assoc.hmskew) > 0)
      return(list(assoc=se.assoc(x$assoc), assoc.hmskew=se.assoc(x$assoc.hmskew)))
  if(length(x$assoc) > 0)
      return(se.assoc(x$assoc))
  else if(length(x$assoc.hmskew) > 0)
      return(se.assoc(x$assoc.hmskew))
  else
      stop("x must have an association or a skew-association component")
}

se.yrcskew <- function(x, type=c("se", "quasi.se"), ...) {
  if(!inherits(x, "se.yrcskew"))
      stop("x must be a se.yrcskew object")

  if(length(x$assoc) > 0 && length(x$assoc.yrcskew) > 0)
      return(list(assoc=se.assoc(x$assoc), assoc.yrcskew=se.assoc(x$assoc.yrcskew)))
  if(length(x$assoc) > 0)
      return(se.assoc(x$assoc))
  else if(length(x$assoc.yrcskew) > 0)
      return(se.assoc(x$assoc.yrcskew))
  else
      stop("x must have an association or a skew-association component")
}

se.assoc <- function(x, type=c("se", "quasi.se"), ...) {
  type <- match.arg(type)

  if(!inherits(x, "assoc"))
      stop("x must be an assoc object")

  if(x$covtype == "none" || length(x$covmat) == 0)
      stop("No covariance matrix found: use the 'se' argument when fitting model")

  if(!(ncol(x$row) == ncol(x$col) &&
       ncol(x$phi) == ncol(x$row)))
      stop("Invalid component length")

  nd <- ncol(x$phi)
  nl <- nrow(x$phi)

  if(nrow(x$covmat) != ncol(x$covmat) ||
     nrow(x$covmat) != nl * nd + 2 * nl * nd * (nrow(x$row) + nrow(x$col)))
      stop("Covariance matrix dimensions do not match association structure")

  std.errs <- list()

  if(type == "quasi.se") {
      get.se <- function(covmat) qvcalc::qvcalc(covmat)$qvframe$quasiSE
  }
  else {
      get.se <- function(covmat) sqrt(diag(covmat))
  }

  covmat <- x$covmat

  std.errs$phi <- x$phi
  for(i in 1:nl)
      std.errs$phi[i,] <- get.se(covmat[seq((i - 1) * nd + 1, i * nd), seq((i - 1) * nd + 1, i * nd)])

  std.errs$row <- x$row
  n <- nrow(std.errs$row)
  for(i in 1:dim(std.errs$row)[3]) {
      for(j in 1:nd) {
          int <- seq(nl * nd + n * (j - 1) + 1, nl * nd + n * j)
          std.errs$row[,j,i] <- get.se(covmat[int, int, drop=FALSE])
      }
  }

  std.errs$col <- x$col
  if(inherits(x, "assoc.symm")) {
      std.errs$col <- std.errs$row
  }
  else {
      n <- nrow(std.errs$col)
      start <- nl * nd + nd * nrow(std.errs$row)
      for(i in 1:dim(std.errs$col)[3]) {
          for(j in 1:nd) {
              int <- seq(start + n * (j - 1) + 1, start + n * j)
              std.errs$col[,j,i] <- get.se(covmat[int, int, drop=FALSE])
          }
      }
  }

  std.errs
}
